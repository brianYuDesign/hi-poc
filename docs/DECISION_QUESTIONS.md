# 待确认议题 - 决策问答

本文档通过问答方式协助推进关键决策，每个议题都包含背景、选项、建议和决策记录。

---

## 议题 1: API 协议选择

### ❓ 问题
**选择 REST 还是 REST API？**

### 📋 背景
- 系统需要对外提供余额查询和变更接口
- 需要支持高并发、低延迟
- 可能需要支持多种客户端（Web、移动端、内部服务）

### 🔍 选项分析

#### 选项 A: REST
**优势**:
- ✅ 性能优异（HTTP/2 + Protobuf 二进制序列化）
- ✅ 类型安全（Protocol Buffers）
- ✅ 流式传输支持
- ✅ 自动生成客户端代码
- ✅ 适合内部服务间通信

**劣势**:
- ❌ 浏览器支持有限（需要 REST-Web）
- ❌ 调试相对复杂
- ❌ 生态相对较小

**适用场景**:
- 内部服务间通信
- 高性能要求
- 强类型需求

#### 选项 B: REST API
**优势**:
- ✅ 广泛支持（浏览器、移动端、各种语言）
- ✅ 易于调试（HTTP 工具）
- ✅ 生态成熟
- ✅ 缓存友好（HTTP 标准）

**劣势**:
- ❌ 性能相对较低（JSON 序列化）
- ❌ 类型安全需要额外验证
- ❌ 无流式传输

**适用场景**:
- 对外 API
- Web 前端调用
- 需要广泛兼容性

#### 选项 C: 混合方案
**优势**:
- ✅ 内部服务用 REST（高性能）
- ✅ 对外 API 用 REST（兼容性）
- ✅ 最佳实践组合

**劣势**:
- ❌ 需要维护两套接口
- ❌ 开发成本较高

### 💡 建议
**推荐选项 C（混合方案）**，理由：
1. 内部服务间通信使用 REST，获得最佳性能
2. 对外 API 使用 REST，保证兼容性
3. 可以分阶段实施（先 REST，后 REST）

### ❓ 你的决策
- [ ] **选项 A**: 仅使用 REST
- [ ] **选项 B**: 仅使用 REST API
- [ ] **选项 C**: 混合方案（推荐）
- [ ] **其他**: ________________

**决策理由**: 
_________________________________________________

---

## 议题 2: 监控方案

### ❓ 问题
**使用 Prometheus + Grafana 还是其他监控方案？**

### 📋 背景
- 需要监控系统性能指标（TPS、延迟、错误率）
- 需要可视化仪表板
- 需要告警机制

### 🔍 选项分析

#### 选项 A: Prometheus + Grafana（当前方案）
**优势**:
- ✅ 开源免费
- ✅ 生态成熟
- ✅ 强大的查询语言（PromQL）
- ✅ 丰富的可视化
- ✅ 社区支持好

**劣势**:
- ❌ 需要自行维护
- ❌ 存储成本（长期数据）

**适用场景**:
- 中小型项目
- 需要自定义指标
- 预算有限

#### 选项 B: 商业监控方案（Datadog, New Relic 等）
**优势**:
- ✅ 开箱即用
- ✅ 专业支持
- ✅ 高级功能（APM、日志聚合）
- ✅ 无需维护

**劣势**:
- ❌ 成本较高
- ❌ 数据隐私（SaaS）

**适用场景**:
- 大型项目
- 预算充足
- 需要专业支持

#### 选项 C: 云原生方案（CloudWatch, Azure Monitor 等）
**优势**:
- ✅ 与云平台集成
- ✅ 统一管理
- ✅ 按需付费

**劣势**:
- ❌ 平台锁定
- ❌ 功能可能受限

**适用场景**:
- 已使用特定云平台
- 需要云平台集成

### 💡 建议
**推荐选项 A（Prometheus + Grafana）**，理由：
1. 已在 docker-compose 中配置
2. 开源免费，适合 PoC 和初期项目
3. 功能完整，满足需求
4. 后续可以迁移到商业方案

### ❓ 你的决策
- [ ] **选项 A**: Prometheus + Grafana（推荐）
- [ ] **选项 B**: 商业监控方案
- [ ] **选项 C**: 云原生方案
- [ ] **其他**: ________________

**决策理由**: 
_________________________________________________

---

## 议题 3: 日志方案

### ❓ 问题
**使用 ELK Stack 还是其他日志方案？**

### 📋 背景
- 需要集中式日志管理
- 需要日志搜索和分析
- 需要日志持久化

### 🔍 选项分析

#### 选项 A: ELK Stack (Elasticsearch + Logstash + Kibana)
**优势**:
- ✅ 功能强大（搜索、分析、可视化）
- ✅ 生态成熟
- ✅ 开源免费
- ✅ 支持大规模数据

**劣势**:
- ❌ 资源消耗大（内存）
- ❌ 配置复杂
- ❌ 需要维护

**适用场景**:
- 需要复杂日志分析
- 大规模日志量
- 有运维团队

#### 选项 B: Loki + Grafana
**优势**:
- ✅ 轻量级（相比 ELK）
- ✅ 与 Grafana 集成
- ✅ 标签索引（高效）
- ✅ 资源消耗低

**劣势**:
- ❌ 功能相对简单
- ❌ 生态较小

**适用场景**:
- 中小型项目
- 已有 Grafana
- 资源有限

#### 选项 C: 云日志服务（CloudWatch Logs, Azure Log Analytics 等）
**优势**:
- ✅ 无需维护
- ✅ 与云平台集成
- ✅ 自动扩展

**劣势**:
- ❌ 成本（按量计费）
- ❌ 平台锁定

**适用场景**:
- 已使用云平台
- 不想维护日志系统

#### 选项 D: 简单方案（文件日志 + 定期归档）
**优势**:
- ✅ 简单直接
- ✅ 无额外依赖
- ✅ 成本低

**劣势**:
- ❌ 搜索困难
- ❌ 无可视化
- ❌ 扩展性差

**适用场景**:
- PoC 阶段
- 日志量小
- 快速验证

### 💡 建议
**推荐选项 B（Loki + Grafana）**，理由：
1. 轻量级，适合 PoC
2. 与已有 Grafana 集成
3. 功能足够（搜索、过滤、可视化）
4. 后续可以升级到 ELK

### ❓ 你的决策
- [ ] **选项 A**: ELK Stack
- [ ] **选项 B**: Loki + Grafana（推荐）
- [ ] **选项 C**: 云日志服务
- [ ] **选项 D**: 简单方案（文件日志）
- [ ] **其他**: ________________

**决策理由**: 
_________________________________________________

---

## 议题 4: 部署方案

### ❓ 问题
**使用 Kubernetes 还是传统部署方式？**

### 📋 背景
- 需要高可用部署
- 需要弹性扩展
- 需要零停机更新

### 🔍 选项分析

#### 选项 A: Kubernetes (K8s)
**优势**:
- ✅ 自动扩展（HPA）
- ✅ 服务发现
- ✅ 滚动更新（零停机）
- ✅ 资源管理
- ✅ 云原生标准

**劣势**:
- ❌ 学习曲线陡峭
- ❌ 运维复杂
- ❌ 资源消耗（控制平面）
- ❌ 需要 K8s 集群

**适用场景**:
- 大规模部署
- 需要弹性扩展
- 有 K8s 运维能力
- 云原生架构

#### 选项 B: Docker Compose + PM2（当前方案）
**优势**:
- ✅ 简单直接
- ✅ 易于理解
- ✅ 资源消耗低
- ✅ 快速部署

**劣势**:
- ❌ 扩展性有限
- ❌ 需要手动管理
- ❌ 无自动扩展

**适用场景**:
- 中小型项目
- PoC 阶段
- 单机/少量服务器
- 快速验证

#### 选项 C: Docker Swarm
**优势**:
- ✅ 比 K8s 简单
- ✅ 内置服务发现
- ✅ 滚动更新
- ✅ 资源消耗低

**劣势**:
- ❌ 功能相对简单
- ❌ 生态较小
- ❌ 社区支持较少

**适用场景**:
- 中等规模
- 需要简单编排
- 不想用 K8s

#### 选项 D: 传统部署（直接运行 Node.js）
**优势**:
- ✅ 最简单
- ✅ 无容器开销
- ✅ 直接调试

**劣势**:
- ❌ 环境一致性差
- ❌ 部署复杂
- ❌ 扩展困难

**适用场景**:
- 开发环境
- 单机部署
- 快速测试

### 💡 建议
**分阶段推荐**：
1. **Phase 1-2 (PoC)**: 选项 B（Docker Compose + PM2）
   - 快速验证
   - 简单部署
   - 成本低

2. **Phase 3-4 (生产)**: 选项 A（Kubernetes）
   - 需要高可用
   - 需要弹性扩展
   - 需要零停机

### ❓ 你的决策
- [ ] **选项 A**: Kubernetes
- [ ] **选项 B**: Docker Compose + PM2（推荐 PoC 阶段）
- [ ] **选项 C**: Docker Swarm
- [ ] **选项 D**: 传统部署
- [ ] **分阶段**: PoC 用 B，生产用 A（推荐）
- [ ] **其他**: ________________

**决策理由**: 
_________________________________________________

---

## 议题 5: 数据库连接池策略

### ❓ 问题
**如何配置 MySQL 连接池？**

### 📋 背景
- 需要处理高并发请求
- 需要平衡性能和资源
- 需要考虑连接数限制

### 🔍 关键参数

#### 连接池大小
- **建议值**: 20-50（根据服务器配置）
- **计算公式**: `(CPU核心数 * 2) + 有效磁盘数`
- **当前配置**: 20（可调整）

#### 队列限制
- **选项 A**: 0（无限制，可能导致内存问题）
- **选项 B**: 100-500（推荐）
- **当前配置**: 0（建议改为 100）

#### 连接超时
- **建议值**: 10-30 秒
- **当前配置**: 默认（建议明确设置）

### 💡 建议
1. 连接池大小：根据实际负载调整（初始 20）
2. 队列限制：设置为 100，避免内存溢出
3. 连接超时：明确设置 30 秒
4. 监控连接数：添加 Prometheus 指标

### ❓ 你的决策
- [ ] **连接池大小**: 20（当前）
- [ ] **连接池大小**: 50
- [ ] **连接池大小**: 其他值 _______
- [ ] **队列限制**: 100（推荐）
- [ ] **队列限制**: 0（当前，不推荐）
- [ ] **队列限制**: 其他值 _______

**决策理由**: 
_________________________________________________

---

## 议题 6: Kafka 分区策略

### ❓ 问题
**如何设置 Kafka Topic 的分区数量？**

### 📋 背景
- 分区数影响并行度
- 需要与 Consumer 实例数匹配
- 分区数不能随意修改

### 🔍 选项分析

#### 选项 A: 3 个分区（当前配置）
**优势**:
- ✅ 适合 PoC
- ✅ 资源消耗低
- ✅ 简单管理

**劣势**:
- ❌ 并行度有限
- ❌ 扩展性受限

#### 选项 B: 10-20 个分区
**优势**:
- ✅ 更好的并行度
- ✅ 支持更多 Consumer
- ✅ 更好的负载均衡

**劣势**:
- ❌ 资源消耗增加
- ❌ 管理复杂度增加

#### 选项 C: 动态分区（按用户数）
**优势**:
- ✅ 灵活扩展
- ✅ 适应负载

**劣势**:
- ❌ 实现复杂
- ❌ 需要额外管理

### 💡 建议
**推荐选项 B（10-20 个分区）**，理由：
1. 支持更多 Consumer 实例
2. 更好的负载均衡
3. 为未来扩展预留空间
4. 分区数可以按需增加（但减少困难）

**分区数计算公式**:
- 最小: Consumer 实例数
- 推荐: Consumer 实例数 * 2
- 最大: 100（Kafka 建议）

### ❓ 你的决策
- [ ] **选项 A**: 3 个分区（当前）
- [ ] **选项 B**: 10-20 个分区（推荐）
- [ ] **选项 C**: 其他值 _______
- [ ] **动态调整**: 是 / 否

**决策理由**: 
_________________________________________________

---

## 议题 7: 错误处理策略

### ❓ 问题
**如何处理消费失败的消息？**

### 📋 背景
- Kafka Consumer 可能处理失败
- 需要决定重试策略
- 需要处理死信消息

### 🔍 选项分析

#### 选项 A: 自动重试（Kafka Consumer）
**优势**:
- ✅ 简单直接
- ✅ Kafka 内置支持
- ✅ 自动处理

**劣势**:
- ❌ 可能无限重试
- ❌ 阻塞消费

#### 选项 B: 死信队列（DLQ）
**优势**:
- ✅ 隔离问题消息
- ✅ 不影响正常消费
- ✅ 可以后续处理

**劣势**:
- ❌ 需要额外 Topic
- ❌ 需要监控

#### 选项 C: 重试 + DLQ 组合
**优势**:
- ✅ 兼顾自动恢复和问题隔离
- ✅ 最佳实践

**劣势**:
- ❌ 实现相对复杂

### 💡 建议
**推荐选项 C（重试 + DLQ）**：
1. 前 3 次失败：自动重试（间隔递增）
2. 超过 3 次：发送到 DLQ
3. 监控 DLQ 大小
4. 定期处理 DLQ 消息

### ❓ 你的决策
- [ ] **选项 A**: 仅自动重试
- [ ] **选项 B**: 仅死信队列
- [ ] **选项 C**: 重试 + DLQ（推荐）
- [ ] **其他**: ________________

**决策理由**: 
_________________________________________________

---

## 决策记录

### 已确认决策

| 议题 | 决策 | 决策日期 | 决策人 | 备注 |
|------|------|----------|--------|------|
| API 协议 | **选项 C: 混合方案** | 2024-01-XX | | 内部服务用 REST，对外 API 用 REST |
| 监控方案 | **选项 A: Prometheus + Grafana** | 2024-01-XX | | 已配置，开源免费，适合 PoC |
| 日志方案 | **选项 B: Loki + Grafana** | 2024-01-XX | | 轻量级，与 Grafana 集成 |
| 部署方案 | **选项 A: Docker Compose + PM2** | 2024-01-XX | | PoC 阶段，简单直接 |

### 已确认决策（续）

| 议题 | 决策 | 决策日期 | 决策人 | 备注 |
|------|------|----------|--------|------|
| 连接池策略 | **选项 A: 小型服务器** | 2024-01-XX | | 连接池 15，队列限制 100 |
| 分区策略 | **选项 A: 保持 3 个分区** | 2024-01-XX | | 适合 PoC，3 个 Consumer |
| 错误处理 | **选项 C: 重试 + DLQ** | 2024-01-XX | | 前 3 次重试，超过进入 DLQ |

### 所有决策已完成 ✅

---

## 下一步行动

完成决策后，请：
1. ✅ 更新 `IMPLEMENTATION_ROADMAP.md` 中的"待确认"部分
2. ✅ 根据决策更新相关配置文件
3. ✅ 更新架构文档
4. ✅ 记录决策理由（便于后续回顾）

---

**提示**: 如果不确定，可以先选择一个方案进行 PoC，后续根据实际情况调整。
